from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from agents.epic_decomposer import root_agent as epic_agent
from google.genai import types
from firestore import epic, story, relationships
from fastapi import HTTPException
from typing import Dict, Any, List
import json

session_service = InMemorySessionService()
USER_ID = "gurpalsingh"
APP_NAME = "epic decomposer"

async def decompose_epic_logic(payload: str):
    input_data = json.loads(payload)
    epic_id = input_data.get("epic_id")

    new_session = session_service.create_session(
        app_name=APP_NAME,
        user_id=USER_ID,
        state={"initial_key": "initial_value"}
    )
    SESSION_ID = new_session.id

    runner = Runner(
        agent=epic_agent,
        app_name=APP_NAME,
        session_service=session_service,
    )

    user_content = types.Content(role="user", parts=[types.Part(text=payload)])

    final_response_text = None

    try:
        async for event in runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=user_content):
            if event.is_final_response() and event.content and event.content.parts:
                final_response_text = event.content.parts[0].text.strip()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error during agent run: {e}")

    if not final_response_text:
        raise HTTPException(status_code=500, detail="No response received from agent.")

    try:
        # Parse the AI response
        response_data = json.loads(final_response_text)
        stories_data = response_data.get("stories", [])
        if not stories_data:
            raise HTTPException(status_code=500, detail="No stories generated by agent")
        
        # Prepare all stories data with epic_id and status
        stories_to_create = [
            {
                **story_item,
                "epic_id": epic_id,
                "status": "todo"  # Default status for new stories
            }
            for story_item in stories_data
        ]
        
        # Bulk create all stories
        created_stories = story.bulk_create_stories(stories_to_create)
        
        # Bulk link stories to epic
        relationships.bulk_link_stories_to_epic([s["id"] for s in created_stories], epic_id)
        
        return created_stories
    except json.JSONDecodeError:
        raise HTTPException(status_code=500, detail="Invalid response format from agent")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating stories: {str(e)}")

async def create_epic_logic(epic_data: Dict[str, Any]) -> Dict[str, Any]:
    try:
        epic_id = epic.create_epic(epic_data)
        return {"id": epic_id, "message": "Epic created successfully"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

async def get_epic_logic(epic_id: str) -> Dict[str, Any]:
    try:
        result = epic.get_epic(epic_id)
        if not result:
            raise HTTPException(status_code=404, detail="Epic not found")
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

async def update_epic_logic(epic_id: str, updates: Dict[str, Any]) -> Dict[str, str]:
    try:
        epic.update_epic(epic_id, updates)
        return {"message": "Epic updated successfully"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

async def list_epics_logic() -> Dict[str, List[Dict[str, Any]]]:
    try:
        epics = epic.list_epics()
        return {"epics": epics}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
